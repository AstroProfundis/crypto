diff --git a/openpgp/ecdh/ecdh.go b/openpgp/ecdh/ecdh.go
index b1c0d4b..5c2f698 100644
--- a/openpgp/ecdh/ecdh.go
+++ b/openpgp/ecdh/ecdh.go
@@ -15,6 +15,7 @@ import (
 
 	"golang.org/x/crypto/openpgp/aes/keywrap"
 	"golang.org/x/crypto/openpgp/internal/algorithm"
+	"golang.org/x/crypto/openpgp/internal/ecc"
 )
 
 type KDF struct {
@@ -22,17 +23,8 @@ type KDF struct {
 	Cipher algorithm.Cipher
 }
 
-type CurveType uint8
-
-const (
-	NISTCurve CurveType = 1
-	Curve25519 CurveType = 2
-	BitCurve CurveType = 3
-	BrainpoolCurve CurveType = 4
-)
-
 type PublicKey struct {
-	CurveType
+	ecc.CurveType
 	elliptic.Curve
 	X, Y *big.Int
 	KDF
@@ -64,7 +56,7 @@ func Encrypt(random io.Reader, pub *PublicKey, msg, curveOID, fingerprint []byte
 	}
 	m := append(msg, padding...)
 
-	if pub.CurveType == Curve25519 {
+	if pub.CurveType == ecc.Curve25519 {
 		return X25519Encrypt(random, pub, m, curveOID, fingerprint)
 	}
 
@@ -90,7 +82,7 @@ func Encrypt(random io.Reader, pub *PublicKey, msg, curveOID, fingerprint []byte
 }
 
 func Decrypt(priv *PrivateKey, vsG, m, curveOID, fingerprint []byte) (msg []byte, err error) {
-	if priv.PublicKey.CurveType == Curve25519 {
+	if priv.PublicKey.CurveType == ecc.Curve25519 {
 		return X25519Decrypt(priv, vsG, m, curveOID, fingerprint)
 	}
 	x, y := elliptic.Unmarshal(priv.Curve, vsG)
diff --git a/openpgp/ecdh/x25519.go b/openpgp/ecdh/x25519.go
index 42f00f7..b82741b 100644
--- a/openpgp/ecdh/x25519.go
+++ b/openpgp/ecdh/x25519.go
@@ -13,9 +13,10 @@ import (
 
 	"golang.org/x/crypto/openpgp/aes/keywrap"
 	"golang.org/x/crypto/curve25519"
+	"golang.org/x/crypto/openpgp/internal/ecc"
 )
 
-func X25519GenerateKey(rand io.Reader) (priv [32]byte, x [32]byte, err error) {
+func X25519GenerateParams(rand io.Reader) (priv [32]byte, x [32]byte, err error) {
 	var n, helper = new (big.Int), new (big.Int)
 	n.SetUint64(1)
 	n.Lsh(n, 252)
@@ -42,8 +43,26 @@ func X25519GenerateKey(rand io.Reader) (priv [32]byte, x [32]byte, err error) {
 	return
 }
 
+func X25519GenerateKey(rand io.Reader, kdf KDF) (priv *PrivateKey, err error) {
+	ci := ecc.FindByName("Curve25519")
+	priv = new(PrivateKey)
+	priv.PublicKey.Curve = ci.Curve
+	d, ephemeralKey, err := X25519GenerateParams(rand)
+	if err != nil {
+		return nil, err
+	}
+	priv.PublicKey.KDF = kdf
+	priv.D = make([]byte, 32)
+	copyReversed(priv.D, d[:])
+	priv.PublicKey.CurveType = ci.CurveType
+	priv.PublicKey.Curve = ci.Curve
+	priv.PublicKey.X = new (big.Int).SetBytes(ephemeralKey[:])
+	priv.PublicKey.Y = new (big.Int)
+	return priv, nil
+}
+
 func X25519Encrypt(random io.Reader, pub *PublicKey, msg, curveOID, fingerprint []byte) (vsG, c []byte, err error) {
-	d, ephemeralKey, err := X25519GenerateKey(random)
+	d, ephemeralKey, err := X25519GenerateParams(random)
 	if err != nil {
 		return nil, nil, err
 	}
@@ -79,19 +98,16 @@ func X25519Encrypt(random io.Reader, pub *PublicKey, msg, curveOID, fingerprint
 
 func X25519Decrypt(priv *PrivateKey, vsG, m, curveOID, fingerprint []byte) (msg []byte, err error) {
 	var zb, d, ephemeralKey[32]byte
-	copy(d[:], priv.D)
 	if len(vsG) != 33 || vsG[0] != 0x40 {
 		return nil,  errors.New("ecdh: invalid key")
 	}
 	copy(ephemeralKey[:], vsG[1:33])
-	
-	for i := 31; i >= 0; i-- {
-		d[31 - i] = priv.D[i]
-	}
+
+	copyReversed(d[:], priv.D)
 	curve25519.ScalarBaseMult(&zb, &d)
 	curve25519.ScalarMult(&zb, &d, &ephemeralKey)
 
-	var bigZb = new (big.Int)
+	var bigZb = new(big.Int)
 	bigZb.SetBytes(zb[:])
 
 	z, err := buildKey(&priv.PublicKey, bigZb, curveOID, fingerprint)
@@ -105,4 +121,10 @@ func X25519Decrypt(priv *PrivateKey, vsG, m, curveOID, fingerprint []byte) (msg
 	}
 
 	return c[:len(c)-int(c[len(c)-1])], nil
+}
+
+func copyReversed(out []byte, in []byte) {
+	for i := 31; i >= 0; i-- {
+		out[31-i] = in[i]
+	}
 }
\ No newline at end of file
diff --git a/openpgp/internal/ecc/curveInfo.go b/openpgp/internal/ecc/curveInfo.go
index cdb9193..a0be959 100644
--- a/openpgp/internal/ecc/curveInfo.go
+++ b/openpgp/internal/ecc/curveInfo.go
@@ -4,7 +4,6 @@ import (
 	"golang.org/x/crypto/openpgp/internal/encoding"
 	"crypto/elliptic"
 	"bytes"
-	"golang.org/x/crypto/openpgp/ecdh"
 	"golang.org/x/crypto/bitcurves"
 	"golang.org/x/crypto/brainpool"
 )
@@ -14,81 +13,81 @@ const (
 	ECDSA SignatureAlgorithm = 1
 	EdDSA SignatureAlgorithm = 2
 )
-type curveInfo struct {
+type CurveInfo struct {
 	Name string
 	Oid *encoding.OID
 	Curve elliptic.Curve
 	SigAlgorithm SignatureAlgorithm
-	CurveType ecdh.CurveType
+	CurveType CurveType
 }
 
-var curves = []curveInfo {
+var curves = []CurveInfo{
 	{
 		Name: "NIST curve P-256",
 		Oid: encoding.NewOID([]byte{0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07}),
 		Curve: elliptic.P256(),
-		CurveType: ecdh.NISTCurve,
+		CurveType: NISTCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "NIST curve P-384",
 		Oid: encoding.NewOID([]byte{0x2B, 0x81, 0x04, 0x00, 0x22}),
 		Curve: elliptic.P384(),
-		CurveType: ecdh.NISTCurve,
+		CurveType: NISTCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "NIST curve P-521",
 		Oid: encoding.NewOID([]byte{0x2B, 0x81, 0x04, 0x00, 0x23}),
 		Curve: elliptic.P521(),
-		CurveType: ecdh.NISTCurve,
+		CurveType: NISTCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "SecP256k1",
 		Oid: encoding.NewOID([]byte{0x2B, 0x81, 0x04, 0x00, 0x0A}),
 		Curve: bitcurves.S256(),
-		CurveType: ecdh.BitCurve,
+		CurveType: BitCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "Curve25519",
 		Oid: encoding.NewOID([]byte{0x2B, 0x06, 0x01, 0x04, 0x01, 0x97, 0x55, 0x01, 0x05, 0x01}),
 		Curve: elliptic.P256(),// filler
-		CurveType: ecdh.Curve25519,
+		CurveType: Curve25519,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "Ed25519",
 		Oid: encoding.NewOID([]byte{0x2B, 0x06, 0x01, 0x04, 0x01, 0xDA, 0x47, 0x0F, 0x01}),
 		Curve: elliptic.P256(), // filler
-		CurveType: ecdh.NISTCurve,
+		CurveType: NISTCurve,
 		SigAlgorithm: EdDSA,
 	},
 	{
 		Name: "Brainpool P256r1",
 		Oid: encoding.NewOID([]byte{0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07}),
 		Curve: brainpool.P256r1(),
-		CurveType: ecdh.BrainpoolCurve,
+		CurveType: BrainpoolCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "BrainpoolP384r1",
 		Oid: encoding.NewOID([]byte{0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B}),
 		Curve: brainpool.P384r1(),
-		CurveType: ecdh.BrainpoolCurve,
+		CurveType: BrainpoolCurve,
 		SigAlgorithm: ECDSA,
 	},
 	{
 		Name: "BrainpoolP512r1",
 		Oid: encoding.NewOID([]byte{0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D}),
 		Curve: brainpool.P512r1(),
-		CurveType: ecdh.BrainpoolCurve,
+		CurveType: BrainpoolCurve,
 		SigAlgorithm: ECDSA,
 	},
 }
 
-func FindByCurve(curve elliptic.Curve) *curveInfo {
+func FindByCurve(curve elliptic.Curve) *CurveInfo {
 	for _, curveInfo := range curves {
 		if curveInfo.Curve == curve {
 			return &curveInfo
@@ -97,7 +96,7 @@ func FindByCurve(curve elliptic.Curve) *curveInfo {
 	return nil
 }
 
-func FindByOid(oid encoding.Field) *curveInfo {
+func FindByOid(oid encoding.Field) *CurveInfo {
 	var rawBytes = oid.Bytes()
 	for _, curveInfo := range curves {
 		if bytes.Equal(curveInfo.Oid.Bytes(), rawBytes) {
@@ -107,7 +106,7 @@ func FindByOid(oid encoding.Field) *curveInfo {
 	return nil
 }
 
-func FindByName(name string) *curveInfo {
+func FindByName(name string) *CurveInfo {
 	for _, curveInfo := range curves {
 		if curveInfo.Name == name {
 			return &curveInfo
diff --git a/openpgp/key_generation.go b/openpgp/key_generation.go
index de1f570..01c78f4 100644
--- a/openpgp/key_generation.go
+++ b/openpgp/key_generation.go
@@ -10,6 +10,8 @@ import (
 	"golang.org/x/crypto/ed25519"
 	"golang.org/x/crypto/openpgp/errors"
 	"golang.org/x/crypto/openpgp/packet"
+	"golang.org/x/crypto/openpgp/ecdh"
+	"golang.org/x/crypto/openpgp/internal/algorithm"
 )
 
 const defaultRSAKeyBits = 2048
@@ -69,13 +71,18 @@ func NewEntity(name, comment, email string, config *packet.Config) (*Entity, err
 		privPrimary = packet.NewEdDSAPrivateKey(currentTime, primaryKey)
 		pubPrimary = packet.NewEdDSAPublicKey(currentTime, pubPrimaryKey)
 
-		pubSubkeyRaw, privSubkeyRaw, err := ed25519.GenerateKey(config.Random())
+		var kdf = ecdh.KDF{
+			Hash:   algorithm.SHA512,
+			Cipher: algorithm.AES256,
+		}
+
+		privSubkeyRaw, err := ecdh.X25519GenerateKey(config.Random(), kdf)
 		if err != nil {
 			return nil, err
 		}
 
-		pubSubkey = packet.NewEdDSAPublicKey(currentTime, pubSubkeyRaw)
-		privSubkey = packet.NewEdDSAPrivateKey(currentTime, privSubkeyRaw)
+		pubSubkey = packet.NewECDHPublicKey(currentTime, &privSubkeyRaw.PublicKey)
+		privSubkey = packet.NewECDHPrivateKey(currentTime, privSubkeyRaw)
 
 		subkeyAlgorithm = packet.PubKeyAlgoEdDSA
 
diff --git a/openpgp/packet/private_key.go b/openpgp/packet/private_key.go
index 2e03b14..a5c4768 100644
--- a/openpgp/packet/private_key.go
+++ b/openpgp/packet/private_key.go
@@ -315,6 +315,13 @@ func serializeEdDSAPrivateKey(w io.Writer, priv ed25519.PrivateKey) error {
 	return err
 }
 
+func serializeECDHPrivateKey(w io.Writer, priv *ecdh.PrivateKey) error {
+	_, err := w.Write(encoding.NewMPI(priv.D).EncodedBytes())
+	return err
+}
+
+
+
 // Decrypt decrypts an encrypted private key using a passphrase.
 func (pk *PrivateKey) Decrypt(passphrase []byte) error {
 	if !pk.Encrypted {
@@ -427,6 +434,8 @@ func (pk *PrivateKey) serializePrivateKey(w io.Writer) (err error) {
 		err = serializeECDSAPrivateKey(w, priv)
 	case ed25519.PrivateKey:
 		err = serializeEdDSAPrivateKey(w, priv)
+	case *ecdh.PrivateKey:
+		err = serializeECDHPrivateKey(w, priv)
 	default:
 		err = errors.InvalidArgumentError("unknown private key type")
 	}
diff --git a/openpgp/packet/public_key.go b/openpgp/packet/public_key.go
index c239e1d..92a2b97 100644
--- a/openpgp/packet/public_key.go
+++ b/openpgp/packet/public_key.go
@@ -124,19 +124,32 @@ func NewECDSAPublicKey(creationTime time.Time, pub *ecdsa.PublicKey) *PublicKey
 }
 
 func NewECDHPublicKey(creationTime time.Time, pub *ecdh.PublicKey) *PublicKey {
-	pk := &PublicKey{
-		CreationTime: creationTime,
-		PubKeyAlgo:   PubKeyAlgoECDH,
-		PublicKey:    pub,
-		p:            encoding.NewMPI(elliptic.Marshal(pub.Curve, pub.X, pub.Y)),
+	var pk *PublicKey
+	var curveInfo *ecc.CurveInfo
+	var kdf = encoding.NewOID([]byte{ 0x1, pub.Hash.Id(), pub.Cipher.Id() })
+	if pub.CurveType == ecc.Curve25519 {
+		pk = &PublicKey{
+			CreationTime: creationTime,
+			PubKeyAlgo:   PubKeyAlgoECDH,
+			PublicKey:    pub,
+			p:            encoding.NewMPI(pub.X.Bytes()),
+			kdf: kdf,
+		}
+		curveInfo = ecc.FindByName("Curve25519")
+	} else {
+		pk = &PublicKey{
+			CreationTime: creationTime,
+			PubKeyAlgo:   PubKeyAlgoECDH,
+			PublicKey:    pub,
+			p:            encoding.NewMPI(elliptic.Marshal(pub.Curve, pub.X, pub.Y)),
+			kdf: kdf,
+		}
+		curveInfo = ecc.FindByCurve(pub.Curve)
 	}
-
-	curveInfo := ecc.FindByCurve(pub.Curve)
 	if curveInfo == nil {
 		panic("unknown elliptic curve")
 	}
 	pk.oid = curveInfo.Oid
-
 	pk.setFingerPrintAndKeyId()
 	return pk
 }
@@ -334,7 +347,7 @@ func (pk *PublicKey) parseECDH(r io.Reader) (err error) {
 	cType := curveInfo.CurveType
 
 	var x, y *big.Int;
-	if cType == ecdh.Curve25519 {
+	if cType == ecc.Curve25519 {
 		x = new(big.Int)
 		x.SetBytes(pk.p.Bytes())
 	} else {
